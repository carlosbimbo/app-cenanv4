import * as TaskManager from "expo-task-manager";
import * as BackgroundFetch from "expo-background-fetch";
import * as Notifications from "expo-notifications";
import { openDatabaseSync } from "expo-sqlite";
import * as SecureStore from 'expo-secure-store';
import { getCurrentNetworkState } from "../Context/NetworkContext";
import { apiFetch } from './api';

// Nombre de la tarea
const TASK_NAME = "SYNC_TASK";

// Base de datos local
const db = openDatabaseSync("auth.db");

// Callback opcional para mostrar logs dentro de la app
let logCallback = null;
export const setLogCallback = (callback) => (logCallback = callback);

// Configuraci√≥n de notificaciones (para mostrar alertas visuales)
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: false,
    shouldSetBadge: false,
  }),
});

// üß© Definici√≥n de la tarea
TaskManager.defineTask(TASK_NAME, async () => {
  const { isConnected, isInternetReachable } = getCurrentNetworkState();
  console.log(isConnected);
  if (isConnected || isInternetReachable) {
  try {
    const now = new Date().toLocaleTimeString();
    const startMsg = `üîÑ [${now}] Ejecutando tarea de sincronizaci√≥n...`;
    console.log(startMsg);
    logCallback?.(startMsg);

    // üîî Notificaci√≥n para confirmar ejecuci√≥n
    await Notifications.scheduleNotificationAsync({
      content: {
        title: "üîÑ Sincronizaci√≥n iniciada",
        body: `Tarea ejecutada a las ${now}`,
      },
      trigger: null,
    });

    // ‚úÖ Consulta usando getAllAsync (m√°s segura que execAsync)
    const registrosusers = await db.getAllAsync(
      "SELECT * FROM users"
    );

    /*if (!registrosusers || registrosusers.length === 0) {
      const msg = `‚úÖ [${now}] No hay registrosusers pendientes`;
      console.log(msg);
      logCallback?.(msg);

      await Notifications.scheduleNotificationAsync({
        content: {
          title: "‚úÖ Sincronizaci√≥n completa",
          body: "No hay registrosusers pendientes.",
        },
        trigger: null,
      });

      return BackgroundFetch.BackgroundFetchResult.NoData;
    }*/

    // Aqu√≠ podr√≠as enviar datos reales al servidor (simulado por ahora)
    console.log(`üì§ [${now}] ${registrosusers.length} registrosusers encontrados`);
    logCallback?.(`üì§ [${now}] ${registrosusers.length} registrosusers encontrados`);

    /*const token = await SecureStore.getItemAsync('authToken');
    console.log(`üì§ [${now}] ${token} es mi token de usuario`);*/

    //Para Etapa Gestacional
    const regis_etapa_gesta = await db.getAllAsync(
      "SELECT * FROM T_05_ETAPA_GESTACIONAL"
    );
    console.log(`üì§ [${now}] ${regis_etapa_gesta.length} regis_etapa_gesta encontrados`);
    logCallback?.(`üì§ [${now}] ${regis_etapa_gesta.length} regis_etapa_gesta encontrados`);
    try {
      const result = await apiFetch('/savetapagesta', {
        method: 'POST',
        body: JSON.stringify(regis_etapa_gesta),
      }, true);

      console.log('‚úÖ ETAPA_GESTACIONAL sincronizado con el servidor:', result);
    } catch (err) {
      console.log('‚ùå Error al sincronizar ETAPA_GESTACIONAL:', err);    
      return;
    }
    //Fin Para Etapa Gestacional

    await Notifications.scheduleNotificationAsync({
      content: {
        title: "‚úÖ Sincronizaci√≥n exitosa",
        //body: `${registrosusers.length} registrosusers procesados correctamente.`,
        body: `{users:${registrosusers.length},etapa_gesta:${regis_etapa_gesta.length}} registros procesados correctamente.`,
      },
      trigger: null,
    });

    return BackgroundFetch.BackgroundFetchResult.NewData;

  } catch (err) {
    const errorMsg = `‚ùå [${new Date().toLocaleTimeString()}] Error: ${err.message}`;
    console.error(errorMsg);
    logCallback?.(errorMsg);

    await Notifications.scheduleNotificationAsync({
      content: {
        title: "‚ùå Error en tarea de sincronizaci√≥n",
        body: err.message,
      },
      trigger: null,
    });

      return BackgroundFetch.BackgroundFetchResult.Failed;
    }
  }
});

// üß± Registrar la tarea
export async function registerBackgroundSync() {
  try {
    const status = await BackgroundFetch.getStatusAsync();

    if (status === BackgroundFetch.BackgroundFetchStatus.Restricted) {
      console.warn("‚ö†Ô∏è Background fetch restringido por el sistema");
      return;
    }

    await BackgroundFetch.registerTaskAsync(TASK_NAME, {
      minimumInterval: 60, // ‚è±Ô∏è cada 1 minuto
      stopOnTerminate: false,
      startOnBoot: true,
    });

    console.log("‚úÖ Background sync registrado correctamente");
  } catch (err) {
    console.error("‚ùå Error registrando background sync:", err);
  }
}
