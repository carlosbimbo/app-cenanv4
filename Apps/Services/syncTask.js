import * as TaskManager from "expo-task-manager";
import * as BackgroundFetch from "expo-background-fetch";
import * as Notifications from "expo-notifications";
import { openDatabaseSync } from "expo-sqlite";
import * as SecureStore from 'expo-secure-store';

// Nombre de la tarea
const TASK_NAME = "SYNC_TASK";

// Base de datos local
const db = openDatabaseSync("auth.db");

// Callback opcional para mostrar logs dentro de la app
let logCallback = null;
export const setLogCallback = (callback) => (logCallback = callback);

// Configuraci√≥n de notificaciones (para mostrar alertas visuales)
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: false,
    shouldSetBadge: false,
  }),
});

// üß© Definici√≥n de la tarea
TaskManager.defineTask(TASK_NAME, async () => {
  try {
    const now = new Date().toLocaleTimeString();
    const startMsg = `üîÑ [${now}] Ejecutando tarea de sincronizaci√≥n...`;
    console.log(startMsg);
    logCallback?.(startMsg);

    // üîî Notificaci√≥n para confirmar ejecuci√≥n
    await Notifications.scheduleNotificationAsync({
      content: {
        title: "üîÑ Sincronizaci√≥n iniciada",
        body: `Tarea ejecutada a las ${now}`,
      },
      trigger: null,
    });

    // ‚úÖ Consulta usando getAllAsync (m√°s segura que execAsync)
    const registros = await db.getAllAsync(
      "SELECT id, dni, nombape FROM users"
    );

    if (!registros || registros.length === 0) {
      const msg = `‚úÖ [${now}] No hay registros pendientes`;
      console.log(msg);
      logCallback?.(msg);

      await Notifications.scheduleNotificationAsync({
        content: {
          title: "‚úÖ Sincronizaci√≥n completa",
          body: "No hay registros pendientes.",
        },
        trigger: null,
      });

      return BackgroundFetch.BackgroundFetchResult.NoData;
    }

    // Aqu√≠ podr√≠as enviar datos reales al servidor (simulado por ahora)
    console.log(`üì§ [${now}] ${registros.length} registros encontrados`);
    logCallback?.(`üì§ [${now}] ${registros.length} registros encontrados`);

    const token = await SecureStore.getItemAsync('authToken');

    console.log(`üì§ [${now}] ${token} es mi toen de usuario`);

    await Notifications.scheduleNotificationAsync({
      content: {
        title: "‚úÖ Sincronizaci√≥n exitosa",
        body: `${registros.length} registros procesados correctamente.${token}`,
      },
      trigger: null,
    });

    return BackgroundFetch.BackgroundFetchResult.NewData;

  } catch (err) {
    const errorMsg = `‚ùå [${new Date().toLocaleTimeString()}] Error: ${err.message}`;
    console.error(errorMsg);
    logCallback?.(errorMsg);

    await Notifications.scheduleNotificationAsync({
      content: {
        title: "‚ùå Error en tarea de sincronizaci√≥n",
        body: err.message,
      },
      trigger: null,
    });

    return BackgroundFetch.BackgroundFetchResult.Failed;
  }
});

// üß± Registrar la tarea
export async function registerBackgroundSync() {
  try {
    const status = await BackgroundFetch.getStatusAsync();

    if (status === BackgroundFetch.BackgroundFetchStatus.Restricted) {
      console.warn("‚ö†Ô∏è Background fetch restringido por el sistema");
      return;
    }

    await BackgroundFetch.registerTaskAsync(TASK_NAME, {
      minimumInterval: 60, // ‚è±Ô∏è cada 1 minuto
      stopOnTerminate: false,
      startOnBoot: true,
    });

    console.log("‚úÖ Background sync registrado correctamente");
  } catch (err) {
    console.error("‚ùå Error registrando background sync:", err);
  }
}
